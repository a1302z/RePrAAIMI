import numpy as np
import os
import sys

os.environ["CUDA_VISIBLE_DEVICES"] = ""
import hydra
import seaborn as sn
import pandas as pd
from copy import deepcopy
from pathlib import Path
from datetime import datetime
from tqdm import tqdm
from matplotlib import pyplot as plt, ticker as mtick

sys.path.insert(0, str(Path.cwd()))

from dptraining.config import Config
from dptraining.privacy import setup_privacy
from dptraining.datasets import make_loader_from_config
from dptraining.config.config_store import load_config_store
from dptraining.vulnerability.sgm_rero import (
    rero_bound_sgm,
)
from dptraining.vulnerability.glrt_rero import rero_bound_glrt

sn.set_theme(
    context="notebook",
    style="white",
    font="Times New Roman",
    # font_scale=2,
    palette="viridis",
)
sn.despine()
sn.set(rc={"figure.figsize": (12, 12)}, font_scale=2)
colors = {
    "red": "firebrick",
    "blue": "steelblue",
    "green": "forestgreen",
    "purple": "darkorchid",
    "orange": "darkorange",
    "gray": "lightslategray",
    "black": "black",
}

load_config_store()


@hydra.main(version_base=None, config_path=Path.cwd() / "configs")
def main(
    train_config: Config,
):
    if "eps_values" in train_config.keys():
        eps_values = train_config.eps_values
    elif all([kwd in train_config.keys() for kwd in ["eps_min", "eps_max", "N_eps"]]):
        eps_values = np.linspace(
            train_config.eps_min,
            train_config.eps_max,
            train_config.N_eps,
            endpoint=True,
        )
    else:
        eps_values = list(range(1000, 100001, 2000))
    train_loader, _, _ = make_loader_from_config(train_config)

    save_folder = (
        Path.cwd()
        / f"theoretical_rero_curves/{str(train_config.dataset.name).split('.')[-1]}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}/"
    )

    total_num = len(train_loader.dataset)
    print(total_num)

    # Number of update training steps.
    steps = (
        len(train_loader) // train_config.hyperparams.grad_acc_steps
    ) * train_config.hyperparams.epochs

    privacy_settings = []
    for eps in eps_values:
        config = deepcopy(train_config)
        config.DP.epsilon = float(eps)
        if config.DP:
            (
                grad_acc,
                accountant,
                sampling_rate,
                delta,
                sigma,
                total_noise,
                batch_expansion_factor,
                effective_batch_size,
            ) = setup_privacy(config, train_loader)
        else:
            raise ValueError(
                "This script is only designed for DP trainings. All other are critically non-private."
            )
        privacy_settings.append((eps, sigma, sampling_rate))

    # %%
    upper_bounds_sgm = np.zeros((len(eps_values),))
    upper_bounds_glrt = np.zeros((len(eps_values),))
    fig, ax = plt.subplots(figsize=(12, 12))
    for j, (eps, sigma, sampling_rate) in tqdm(
        enumerate(privacy_settings),
        total=len(privacy_settings),
        leave=False,
        desc="Privacy levels",
    ):
        sgm_rub = rero_bound_sgm(1.0 / total_num, 1.0 / sigma, sampling_rate, steps)
        glrt_rub = rero_bound_glrt(1.0 / total_num, sigma, 1.0, sampling_rate, steps)
        upper_bounds_sgm[j] = 100.0 * sgm_rub
        upper_bounds_glrt[j] = 100.0 * glrt_rub
    ax.plot(
        eps_values,
        upper_bounds_sgm,
        color=colors["purple"],
        label="Optimal adversary",
    )
    ax.plot(
        eps_values,
        upper_bounds_glrt,
        color=colors["orange"],
        label="GLRT adversary",
    )
    ax.yaxis.set_major_formatter(mtick.PercentFormatter())
    ax.set_xlabel("epsilon")
    ax.set_ylabel("Prior aware upper bound")
    ax.set_ylim(0, 100)
    plt.legend(loc="best")

    if not save_folder.is_dir():
        save_folder.mkdir(parents=True)
    plt.savefig(
        str(save_folder / "theoretical_rero_curve.svg"),
        bbox_inches="tight",
    )
    plt.savefig(
        (save_folder / "theoretical_rero_curve.pdf"),
        bbox_inches="tight",
        dpi=600,
    )
    results = []
    for eps, sgm_bound, glrt_bound in zip(
        eps_values, upper_bounds_sgm, upper_bounds_glrt
    ):
        print(f"{eps}: Standard: {sgm_bound:.2f}% GLRT: {glrt_bound:.2f}%")
        results.append({"sgm": sgm_bound, "glrt": glrt_bound})
    df = pd.DataFrame(results, index=eps_values)
    df.to_csv(str(save_folder / "results.csv"))


if __name__ == "__main__":
    main()
