import numpy as np
import os
import sys

os.environ["CUDA_VISIBLE_DEVICES"] = ""
import hydra
import seaborn as sn
import pandas as pd
from copy import deepcopy
from pathlib import Path
from datetime import datetime
from tqdm import tqdm
from matplotlib import pyplot as plt, ticker as mtick

sys.path.insert(0, str(Path.cwd()))

from dptraining.config import Config
from dptraining.privacy import setup_privacy
from dptraining.datasets import make_loader_from_config
from dptraining.config.config_store import load_config_store
from dptraining.vulnerability.compute_rero_bound import rero_bound_sgm

sn.set_theme(
    context="notebook",
    style="white",
    font="Times New Roman",
    font_scale=2,
    palette="viridis",
)
sn.despine()
sn.set(rc={"figure.figsize": (12, 12)})
colors = {
    "red": "firebrick",
    "blue": "steelblue",
    "green": "forestgreen",
    "purple": "darkorchid",
    "orange": "darkorange",
    "gray": "lightslategray",
    "black": "black",
}

load_config_store()


@hydra.main(version_base=None, config_path=Path.cwd() / "configs")
def main(
    train_config: Config,
):
    upper_bounds = []
    if "eps_values" in train_config.keys():
        eps_values = train_config.eps_values
    elif all([kwd in train_config.keys() for kwd in ["eps_min", "eps_max", "N_eps"]]):
        eps_values = np.linspace(
            train_config.eps_min,
            train_config.eps_max,
            train_config.N_eps,
            endpoint=True,
        )
    else:
        eps_values = list(range(1000, 100001, 2000))
    train_loader, _, _ = make_loader_from_config(train_config)

    save_folder = (
        Path.cwd()
        / f"rero/{str(train_config.dataset.name).split('.')[-1]}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}/"
    )

    total_num = len(train_loader.dataset)
    print(total_num)

    # Number of update training steps.
    steps = (
        len(train_loader) // train_config.hyperparams.grad_acc_steps
    ) * train_config.hyperparams.epochs

    privacy_settings = []
    for eps in eps_values:
        config = deepcopy(train_config)
        config.DP.epsilon = float(eps)
        if config.DP:
            (
                grad_acc,
                accountant,
                sampling_rate,
                delta,
                sigma,
                total_noise,
                batch_expansion_factor,
                effective_batch_size,
            ) = setup_privacy(config, train_loader)
        else:
            raise ValueError(
                "This script is only designed for DP trainings. All other are critically non-private."
            )
        privacy_settings.append((eps, sigma, sampling_rate))

    # %%
    upper_bounds = np.zeros((len(eps_values),))
    for j, (eps, sigma, sampling_rate) in tqdm(
        enumerate(privacy_settings),
        total=len(privacy_settings),
        leave=False,
        desc="Privacy levels",
    ):
        rub = rero_bound_sgm(1.0 / total_num, 1.0 / sigma, sampling_rate, steps)
        upper_bounds[j] = 100.0 * rub
    plt.plot(
        eps_values,
        upper_bounds,
        color="blue",
        label="Upper bounding reconstruction success",
    )
    plt.gca().yaxis.set_major_formatter(mtick.PercentFormatter())
    plt.xlabel("epsilon")
    plt.ylabel("Prior aware upper bound")
    plt.ylim(0, 100)
    # plt.legend(loc="best")

    if not save_folder.is_dir():
        save_folder.mkdir(parents=True)
    plt.savefig(
        str(save_folder / "priorawareupper_bounds.svg"),
        bbox_inches="tight",
    )
    plt.savefig(
        (save_folder / "priorawareupper_bounds.png"),
        bbox_inches="tight",
        dpi=600,
    )
    result_dict = {}
    for eps, bound in zip(
        eps_values,
        upper_bounds,
    ):
        print(f"{eps}: {bound:.2f}")
        result_dict[eps] = bound
    df = pd.DataFrame.from_dict({k: [v] for k, v in result_dict.items()})
    df.to_csv(str(save_folder / "results.csv"))


if __name__ == "__main__":
    main()
